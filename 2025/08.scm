#!/usr/bin/env gosh

(import (scheme base)
        (scheme cxr)
        (scheme process-context)
        (scheme write)
        (srfi 1)
        (srfi 13)
        (srfi 14)
        (srfi 43)
        (srfi 132)
        (advent input)
        (advent main))

(define (string->junction-box s)
  (let ((fields (string-tokenize s (char-set-complement (char-set #\,)))))
    (if (= (length fields) 3)
        (vector (string->number (car fields))
                (string->number (cadr fields))
                (string->number (caddr fields)))
        (error "invalid string" s))))

(define (squared-distance p q)
  (+ (square (- (vector-ref p 0) (vector-ref q 0)))
     (square (- (vector-ref p 1) (vector-ref q 1)))
     (square (- (vector-ref p 2) (vector-ref q 2)))))

(define (read-input)
  (list->vector (map string->junction-box (read-lines))))

(define (junction-distances junctions)
  (let ((n (vector-length junctions)))
    (let loop ((distances '())
               (i 0)
               (j 1))
      (cond
       ((= i (- n 1)) distances)
       ((= j n) (loop distances (+ i 1) (+ i 2)))
       (else (loop (alist-cons (cons i j)
                               (squared-distance (vector-ref junctions i)
                                                 (vector-ref junctions j))
                               distances)
                   i (+ j 1)))))))

(define (connected-components connected)
  (let* ((n (vector-length connected))
         (components (make-vector n -1)))
    (define (dfs i id)
      (when (= (vector-ref components i) -1)
        (vector-set! components i id)
        (for-each (lambda (j) (dfs j id))
                  (vector-ref connected i))))
    (do ((i 0 (+ i 1)))
        ((= i n) components)
      (dfs i i))))

(define (component-lengths components)
  (let* ((n (vector-length components))
         (lengths (make-vector n 0)))
    (vector-for-each (lambda (u c)
                       (vector-set! lengths c (+ (vector-ref lengths c) 1)))
                     components)
    lengths))

;; TODO: Heap.
(define (part-1)
  (let* ((junctions (read-input))
         (n (vector-length junctions))
         (k (string->number (or (get-environment-variable "CONNS") "1000")))
         (distances (list->vector (junction-distances junctions)))
         (adjacency (make-vector n '()))
         )

    ;; (vector-separate! (lambda (a b)
    ;;                     (< (cdr a) (cdr b)))
    ;;                   distances k)
    (vector-sort! (lambda (a b)
                    (< (cdr a) (cdr b)))
                  distances)

    (for-each (lambda (conn)
                (let ((i (caar conn))
                      (j (cdar conn)))
                  (vector-set! adjacency i (cons j (vector-ref adjacency i)))
                  (vector-set! adjacency j (cons i (vector-ref adjacency j)))))
              (vector->list distances 0 k))

    (display junctions) (newline)
    (newline)
    (display distances) (newline)
    (newline)
    (display (vector->list distances 0 k)) (newline)
    (newline)
    (display adjacency) (newline)
    (newline)
    (display (connected-components adjacency)) (newline)
    (newline)
    (display (component-lengths (connected-components adjacency))) (newline)
    (newline)
    (display (vector-sort > (component-lengths (connected-components adjacency)))) (newline)
    ))

(define (part-2)
  ;; TODO
  )

(main part-1 part-2)
